---
title: "Glossy Buckthorn CA"
author: "Tim Szewczyk"
date: "9/15/2017"
output: html_document
---

# readme  
This is a wrapper for running the glossy buckthorn cellular automata model. It sets up the environment, allows the assignment of all necessary parameters, runs the simulation, and visualizes the results.

The land cover within each cell is compositional rather than the more common hard classification. As a result, all land cover-specific parameters are computed proportionally to the land cover in a cell (i.e., lc.prop %*% K, where lc.prop is a matrix with columns for land cover and a row for each cell, and K is a vector of carrying capacities with one per land cover type).

```{r setup, include=FALSE}
if(!require(sevcheck)) devtools::install_github("Sz-Tim/sevcheck")
p_load("tidyverse", "doParallel", "magrittr", "stringr")
theme_set(theme_bw()); registerDoParallel(makeCluster(2))
source("code/ca_fn.R")
```


```{r setPars}
##---
## set parameters
##---

  # simulation
  tmax <- 15  # num time steps per simulation
  n.sim <- 1  # num simulations
  stoch <- FALSE  # include stochasticity in demographic processes?
  
  # landscape
  lc.r <- 108  # num rows in landscape
  lc.c <- 81  # num columns in landscape
  n.lc <- 6  # num land cover categories
  N.p.t0 <- 3  # num cells with buckthorn at t=1
  
  # demography
  K <- c(1000, 10, 200, 600, 300, 300)  # carrying capacity for adults in each lc
  pr.f <- c(0.9, 0.1, 0.2, 0.4, 0.2, 0.3)  # pr(fruit) in each lc
  fec <- c(300, 20, 40, 50, 40, 30)  # mean(fruit per adult) in each lc
  pr.est <- c(0.2, 0.05, 0.05, 0.02, 0.05, 0.1)  # pr(seedling establish) in each lc
  
  # dispersal
  sdd.max <- 3  # maximum dispersal distance (in cells)
  sdd.rate <- 3.5  # 1/mn for dispersal kernel
  bird.pref <- c(1,0.2,0.5,0.8,0.8,0.5) %>% divide_by(sum(.))  # bird habitat prefs
  pr.eat <- rbeta(n.lc, 1.5, 2)  # prop fruits eaten by birds
  n.ldd <- 1  # num long distance dispersal events per year
  

##--
## initialize landscape
##--
  
  # land cover
  ncell <- lc.r*lc.c
  blockSize <- 5; maxGridCol <- lc.c; maxGridRow <- lc.r
  
  cb.i <- read_csv(paste0("data/roads_01_1a.csv")) %>% 
    mutate(CellRow=1:n_distinct(top) %>% rep(n_distinct(left)),
           CellCol=1:n_distinct(left) %>% rep(each=n_distinct(top))) %>%
    filter((CellRow <= max((CellRow %/% blockSize) * blockSize)) &
             (CellCol <= max((CellCol %/% blockSize) * blockSize))) %>%
    mutate(BlockRow=((CellRow-1)%/%blockSize)+1, 
           BlockCol=((CellCol-1)%/%blockSize)+1,
           BlockID=paste(str_pad(BlockCol, 7, "left", "0"), 
                         str_pad(BlockRow, 7, "left", "0"), sep=".") %>% 
             as.numeric %>% factor %>% as.numeric) %>%
    select(c(CellID, CellRow, CellCol, BlockID, BlockRow, BlockCol, left, top))
  
  Block.inc <- cb.i$BlockID[cb.i$BlockCol <= maxGridCol &
                            cb.i$BlockRow <= maxGridRow] %>% unique
  
  grnt <- read_csv(paste0("data/out_01_1a_grnt.csv")) %>% 
    mutate(CellID=1:nrow(.)) %>% add_blocks(cb.i=cb.i) %>% 
    summarise(Dev=sum(V1)/n(), Oth=sum(V2)/n(), Hwd=sum(V3)/n(), 
              WP=sum(V4)/n(), Evg=sum(V5)/n(), Mxd=sum(V6)/n()) %>%
    filter(BlockID %in% Block.inc) 
  
  lc.df <- tibble(x=cb.i$BlockCol[match(grnt$BlockID, cb.i$BlockID)],
                  y=cb.i$BlockRow[match(grnt$BlockID, cb.i$BlockID)],
                  Dev=grnt$Dev, Oth=grnt$Oth, Hwd=grnt$Hwd,
                  WP=grnt$WP, Evg=grnt$Evg, Mxd=grnt$Mxd)
  
  # populations
  N.init <- rep(0, ncell)
  p.0 <- sample(1:ncell, N.p.t0)
  N.init[p.0] <- (as.matrix(lc.df[p.0,3:8]) %*% (K/2)) %>% ceiling
  
  # dispersal probabilities
  sdd.pr <- sdd_set_probs(lc.df, sdd.max, sdd.rate, bird.pref)
```

```{r runSim}

for(s in 1:n.sim) {
  out <- run_sim(lc.df, N.init, K, fec, pr.f, pr.eat, sdd.pr, sdd.rate, 
                      n.ldd, pr.est, tmax, stoch=FALSE)
}
```


```{r plots}
colnames(out) <- paste0("t_", 1:ncol(out))
N.out <- cbind(lc.df, out) %>% as.tibble

for(t in 1:tmax) {
  p.t <- ggplot(N.out, aes(x=x, y=y)) + 
    geom_tile(aes_string(fill=paste0("t_", t))) + 
    scale_fill_gradient(low="white", high="red", 
                        limits=range(out[,-ncol(out)]))
  print(p.t)
}
ggplot(N.out, aes(x=Dev)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
ggplot(N.out, aes(x=Oth)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
ggplot(N.out, aes(x=Hwd)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
ggplot(N.out, aes(x=WP)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
ggplot(N.out, aes(x=Evg)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
ggplot(N.out, aes(x=Mxd)) + 
  geom_point(aes_string(y=paste0("t_", tmax)), alpha=0.1)
```




